<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  <title>Leaflet Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body, html { margin: 0; height: 100%; overflow: hidden; }
    svg { width: 100%; height: 100%; background-color: #fafafa; }
    text { font-size: 10px; font-family: sans-serif; }
    circle { fill: blue; }
</style>
</head>
<body>
  <svg id="map">

    <!-- Dynamic layers
    <g id="markers"></g>
    <g id="routes"></g> -->
  </svg>
  <button id="button" onclick="onMapClick({ latlng: map.getCenter() })">click me</button>
  <p id="var"></p>
  <p id="xcoor"></p>
  <p id="ycoor"></p>
  <p id="returnVal"></p>
  <script>
    const svg = document.getElementById('map');
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    svg.appendChild(g);

    window.console.log = function(message) {
        if (window.javaConnector) {
            window.javaConnector.log(message);
        }
    };

    

    // function onMapClick(e) {
    //   document.getElementById("var").innerText = message;
    //   document.getElementById("xcoor").innerText = e.latlng.lat;
    //   document.getElementById("ycoor").innerText = e.latlng.lng;
    //   document.getElementById("returnVal").innerText = javaConnector.getCount();     
    //   javaConnector.logCoordinates( e.latlng.lat, e.latlng.lng)
    // }



    // map.on('click', onMapClick);

  

    // map.addEventListener('click', function(e) {
    //     const pt = map.createSVGPoint();
    //     pt.x = e.clientX;
    //     pt.y = e.clientY;
    //     const svgP = pt.matrixTransform(map.getScreenCTM().inverse());

    //     console.log('Clicked at:', svgP.x.toFixed(2), svgP.y.toFixed(2));

    //     if (typeof javaConnector !== 'undefined') {
    //         javaConnector.logCoordinates(svgP.x, svgP.y);
    //     }

    //     addMarker(svgP.x, svgP.y);
    //     points.push([svgP.x, svgP.y]);

    //     if (points.length >= 2) {
    //         drawRoute(points);
    //     }
    // });

    // function addMarker(x, y) {
    //     const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    //     circle.setAttribute("cx", x);
    //     circle.setAttribute("cy", y);
    //     circle.setAttribute("r", 5);
    //     circle.classList.add("marker");
    //     markersLayer.appendChild(circle);
    // }

    const bounds = {
      minLon: 38.65,  // left
      maxLon: 38.85,  // right
      minLat: 8.85,   // bottom
      maxLat: 9.15    // top
    };

    let width = 1000;
    let height = 800;

    function project(lon, lat, bounds, width, height) {
      const x = ((lon - bounds.minLon) / (bounds.maxLon - bounds.minLon)) * width * 1.02;  // Stretch longitude a bit
      const y = height - ((lat - bounds.minLat) / (bounds.maxLat - bounds.minLat)) * height;
      return [x, y];
    }  

    fetch('AASTU.geojson')
    .then(response => response.json())
    .then(data => {
      document.getElementById("var").innerText = "Fetched";
      draw(data);
    })
    .catch(error => {
      console.error('Error loading GeoJSON:', error);
    });

  //   function drawRoads(geojson) {
  //     const routesLayer = document.getElementById('routes');

  //     geojson.features.forEach(feature => {
  //         if (feature.geometry.type === 'LineString') {
  //             const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
              
  //             const coor = project(feature.geometry.coordinates[0][0],feature.geometry.coordinates[0][1], bounds, width, height)
  //               // document.getElementById("xcoor").innerText = feature.geometry.coordinates[0];
  //               // document.getElementById("ycoor").innerText = feature.geometry.coordinates[1];
  //             const pointsAttr = feature.geometry.coordinates
  //                 .map(coord => {
  //                   console.log(coord);
  //                   const [lon, lat] = coord; // Extract longitude and latitude
  //                   const [x, y] = project(lon, lat, bounds, width, height); // Project to x, y
  //                   return `${x},${y}`; 
  //                 }) // assuming [x, y] order
  //                 .join(' ');
              
  //             polyline.setAttribute('points', pointsAttr);
  //             polyline.classList.add('route-line');
  //             routesLayer.appendChild(polyline);
  //         }
  //     });
  // }





// Draw nodes
    function draw(geojson) {
      const width = 1000;
      const height = 800;
      console.log('SVG dimensions:', width, height);
      g.innerHTML = ''; // clear previous
    
      geojson.features.forEach(feature => {
        if (feature.geometry.type === "Point") {
          const [lon, lat] = feature.geometry.coordinates;
          const [x, y] = project(lon, lat, bounds ,width, height);
          console.log(lon+','+lat);
          console.log(x+','+y);
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', x);
          circle.setAttribute('cy', y);
          circle.setAttribute('r', 3);
          g.appendChild(circle);

          // const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          // text.setAttribute('x', x + 4);
          // text.setAttribute('y', y - 4);
          // text.textContent = feature.properties.name || feature.id;
          // g.appendChild(text);
      }
    });
  }

// Simple zoom
    // Pan and zoom logic
    let scale = 1;
    let translateX = 0;
    let translateY = 0;
    let isDragging = false;
    let startX, startY;

    function updateTransform() {
      g.setAttribute('transform', `translate(${translateX},${translateY}) scale(${scale})`);
    }

    svg.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomIntensity = 0.1;
      const direction = e.deltaY > 0 ? -1 : 1;
      const factor = (1 + zoomIntensity * direction);
    
      const rect = svg.getBoundingClientRect();
      const offsetX = e.clientX - rect.left;
      const offsetY = e.clientY - rect.top;
    
      translateX -= offsetX / scale;
      translateY -= offsetY / scale;
      scale *= factor;
      translateX += offsetX / scale;
      translateY += offsetY / scale;
    
      updateTransform();
    });

    svg.addEventListener('mousedown', (e) => {
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      svg.style.cursor = 'grabbing';
    });

    svg.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = (e.clientX - startX);
      const dy = (e.clientY - startY);
      startX = e.clientX;
      startY = e.clientY;
      translateX += dx / scale;
      translateY += dy / scale;
      updateTransform();
    });

    svg.addEventListener('mouseup', () => {
      isDragging = false;
      svg.style.cursor = 'grab';
    });

    svg.addEventListener('mouseleave', () => {
      isDragging = false;
      svg.style.cursor = 'grab';
    });


    window.addEventListener('resize', () => {
      draw();
      updateTransform();
    });
  </script>
</body>
</html>
